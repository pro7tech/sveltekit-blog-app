// GENERATED by @edgedb/generate v0.0.7
// Run 'npx @edgedb/generate edgeql-js' to re-generate

import { ExpressionKind, TypeKind, Cardinality } from "edgedb/dist/reflection/index.js";
import { cardutil } from "./cardinality.mjs";
import { literalToTypeSet } from "./castMaps.mjs";
import { $arrayLikeIndexify, $tuplePathify } from "./collections.mjs";
import { $toEdgeQL } from "./toEdgeQL.mjs";
import { $queryFunc, $queryFuncJSON } from "./query.mjs";
function PathLeaf(root, parent, exclusive, scopeRoot = null) {
    return $expressionify({
        __kind__: ExpressionKind.PathLeaf,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __scopeRoot__: scopeRoot
    });
}
function getStarShapeFromPointers(pointers) {
    const shape = {};
    for (const [key, ptr] of Object.entries(pointers)) {
        if (ptr.__kind__ === "property") {
            shape[key] = true;
        }
    }
    return shape;
}
function PathNode(root, parent, scopeRoot = null) {
    const obj = {
        __kind__: ExpressionKind.PathNode,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __scopeRoot__: scopeRoot
    };
    Object.defineProperty(obj, "*", {
        writable: false,
        value: getStarShapeFromPointers(obj.__element__.__pointers__)
    });
    return $expressionify(obj);
}
const _pathCache = Symbol();
const _pointers = Symbol();
const pathifyProxyHandlers = {
    get(target, prop, proxy) {
        var _a, _b, _c;
        const ptr = target[_pointers][prop];
        if (ptr) {
            return ((_a = target[_pathCache][prop]) !== null && _a !== void 0 ? _a : (target[_pathCache][prop] = (ptr.__kind__ === "property" ? PathLeaf : PathNode)({
                __element__: ptr.target,
                __cardinality__: cardutil.multiplyCardinalities(target.__cardinality__, ptr.cardinality)
            }, {
                linkName: prop,
                type: proxy
            }, (_b = ptr.exclusive) !== null && _b !== void 0 ? _b : false, (_c = target.__scopeRoot__) !== null && _c !== void 0 ? _c : (scopeRoots.has(proxy) ? proxy : null))));
        }
        return target[prop];
    }
};
export function $pathify(_root) {
    if (_root.__element__.__kind__ !== TypeKind.object) {
        return _root;
    }
    const root = _root;
    let pointers = {
        ...root.__element__.__pointers__
    };
    if (root.__parent__) {
        const { type, linkName } = root.__parent__;
        const parentPointer = type.__element__.__pointers__[linkName];
        if ((parentPointer === null || parentPointer === void 0 ? void 0 : parentPointer.__kind__) === "link") {
            pointers = { ...pointers, ...parentPointer.properties };
        }
    }
    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {
        if (pointers[key])
            continue;
        const valType = val === null || val === void 0 ? void 0 : val.__element__;
        if (!valType)
            continue;
        pointers[key] = {
            __kind__: valType.__kind__ === TypeKind.object ? "link" : "property",
            properties: {},
            target: val.__element__,
            cardinality: val.__cardinality__,
            exclusive: false,
            computed: true,
            readonly: true,
            hasDefault: false
        };
    }
    root[_pointers] = pointers;
    root[_pathCache] = {};
    return new Proxy(root, pathifyProxyHandlers);
}
function isFunc(expr) {
    return $expressionify({
        __kind__: ExpressionKind.TypeIntersection,
        __cardinality__: this.__cardinality__,
        __element__: {
            ...expr.__element__,
            __shape__: { id: true }
        },
        __expr__: this
    });
}
function assert_single(expr) {
    return $expressionify({
        __kind__: ExpressionKind.Function,
        __element__: expr.__element__,
        __cardinality__: cardutil.overrideUpperBound(expr.__cardinality__, "One"),
        __name__: "std::assert_single",
        __args__: [expr],
        __namedargs__: {}
    });
}
const jsonDestructureProxyHandlers = {
    get(target, prop, proxy) {
        if (typeof prop === "string" && !(prop in target)) {
            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;
            return jsonDestructure.call(proxy, parsedProp);
        }
        return target[prop];
    }
};
function jsonDestructure(path) {
    const pathTypeSet = literalToTypeSet(path);
    return $expressionify({
        __kind__: ExpressionKind.Operator,
        __element__: this.__element__,
        __cardinality__: cardutil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),
        __name__: "[]",
        __opkind__: "Infix",
        __args__: [this, pathTypeSet]
    });
}
export function $jsonDestructure(_expr) {
    if (_expr.__element__.__kind__ === TypeKind.scalar &&
        _expr.__element__.__name__ === "std::json") {
        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);
        expr.destructure = jsonDestructure.bind(expr);
        return expr;
    }
    return _expr;
}
export function $expressionify(_expr) {
    const expr = $pathify($jsonDestructure($arrayLikeIndexify($tuplePathify(_expr))));
    expr.run = $queryFunc.bind(expr);
    expr.runJSON = $queryFuncJSON.bind(expr);
    expr.is = isFunc.bind(expr);
    expr.toEdgeQL = $toEdgeQL.bind(expr);
    expr.assert_single = () => assert_single(expr);
    return Object.freeze(expr);
}
const scopedExprCache = new WeakMap();
const scopeRoots = new WeakSet();
export function $getScopedExpr(expr, existingScopes) {
    let scopedExpr = scopedExprCache.get(expr);
    if (!scopedExpr || (existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.has(scopedExpr))) {
        const isFreeObject = expr.__cardinality__ === Cardinality.One &&
            expr.__element__.__name__ === "std::FreeObject";
        const isInsert = expr.__kind__ === ExpressionKind.Insert;
        scopedExpr =
            isFreeObject || isInsert
                ? expr
                : $expressionify({
                    ...expr,
                    __cardinality__: Cardinality.One,
                    __scopedFrom__: expr,
                    ...(expr.__element__.__kind__ === TypeKind.object
                        ? {
                            "*": getStarShapeFromPointers(expr.__element__.__pointers__)
                        }
                        : {})
                });
        scopeRoots.add(scopedExpr);
        const uncached = !scopedExpr;
        if (uncached) {
            scopedExprCache.set(expr, scopedExpr);
        }
    }
    existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.add(scopedExpr);
    return scopedExpr;
}
export { PathLeaf as $PathLeaf, PathNode as $PathNode };
